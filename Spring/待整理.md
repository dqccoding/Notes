[toc]

### 待整理

### 1.反射

没有反射就没有面向对象，Spring 的ioc容器创建对象都是依赖反射技术。

**需要掌握反射创建对象的方式**，获取类的class对象的三种方式

### 2.看完这一遍视频以后自己创建一个项目开始整理笔记

### 3.课程源码看能不能找到

### 4.refresh()方法的13个子方法的作用以及大致过程

### 5.为什么set()方法可以解决循环依赖的问题，但是构造方法不行？

### 6.循环依赖的核心就是实例化和初始化分开处理，然后提前暴露对象

### 7.懒加载可以解决循环依赖的问题吗?

### 8.三级缓存的ObjectFactory()是什么东西？

是一个函数式接口，仅有一个方法，可以传入一个lambda表达式，可以是匿名内部类，通过调用getObject方法来执行具体的逻辑。

Spring创建对象之前都是先从容器中查找，查找不到就创建

getBean() -> doGetBean() -> createBean->doCreateBean

从三级缓存中查找数据，先查找一级缓存，再查找二级缓存，最后从三级缓存中查找

### 9.三级缓存解决循环依赖问题的关键是什么？为什么通过提前暴露可以解决？

实例化和初始化分开操作，在中间过程中给替他对象赋值的时候，并不是一个完整对象，而是把半成品对象赋值给了其他对象

### 10.一级缓存能否解决循环依赖的问题？

不能，在整个处理过程中，缓存中 放的是半成品和成品对象，如果只有一级缓存，那么半成品和成品对象都会放到一级缓存中，有可能在获取过程中获取到半成品对象，此时半成品对象是无法使用的，不能直接进行相关的处理，因此要把半成品和成品存放的空间分隔开来。

### 11.只使用二级缓存行不行？为什么一定要用三级缓存？

如果可以保证所有的bean对象都不去调用getEarlyReference这个方法，使用耳机缓存是可行的。使用三级缓存的本质在于使用AOP代理问题。

### 12.如果某个bean对象为代理对象，那么会不会创建普通的bean对象呢？

会，先会创建一个普通对象再根据对象的定义判断是否要生成代理对象

### 13.为什么使用了三级缓存就可以解决aop代理的问题？

当一个对象需要被代理的时候，在整个创建过程中是包含了两个对象，一个是普通对象，一个是代理生成的对象，两个bean都是默认单例的，在整个生命周期的处理环节中，一个bean name不能对应两个对象？在bean的使用过程中需要加一层判断，判断一下是否需要进行代理的处理。

